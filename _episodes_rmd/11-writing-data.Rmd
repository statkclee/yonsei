---
title: 데이터를 저장하기
teaching: 10
exercises: 10
questions:
- "R에서 그래프와 데이터를 어떻게 저장할 수 있을까?"
objectives:
- "R에서 데이터와 도식화 결과물을 파일에 저장한다."
keypoints:
- "'Export' 버튼을 사용해서 RStudio로부터 그래프를 저장한다."
- "`write.table()` 함수를 사용해서 표형식 데이터를 저장한다."
source: Rmd
---

```{r, include=FALSE}
source("../bin/chunk-options.R")
knitr_fig_path("11-")
# Silently load in the data so the rest of the lesson works
library("ggplot2")
gapminder <- read.csv("data/gapminder_data.csv", header=TRUE)
# Temporarily create a cleaned-data directory so that the writing examples work
# The students should have created this in topic 2.
dir.create("cleaned-data")
```

## 그림 저장하기

`ggsave` 명령어를 사용해서, 
`ggplot2`에서 생성한 가장 최신 도식화 결과물을 저장하는 방법을 이미 살펴봤다.
다시금 상기시키기 위해 명령어를 적어보면 다음과 같다:


```{r, eval=FALSE}
ggsave("My_most_recent_plot.pdf")
```

RStudio 내부에서 그림으로 저장할 경우,
'Plot' 윈도우에서 'Export' 내보내기 버튼을 사용한다.
버튼을 클릭하면, `.pdf`, `.png`, `.jpg` 혹은 다른 이미지 형식으로 저장할지 
선택옵션을 제시된다.

종종, 'Plot' 윈도우에 먼저 찍어보지 말고, 도표를 저장하고 싶을 때도 있다.
아마도 여러 페이지에 걸친 pdf 문서를 생성하고 싶을 것이다:
예를 들어, 각각은 다른 도표로 말이다.
혹은, 다수 파일에서 부분집합으로 데이터를 뽑아내고,
각 하위 데이터에 대해 도식화를 하고, 결과물을 도표로 저장하고자 한다.
하지만, 각각에 대해 'Export' 내보내기 버튼을 클릭하려고 루프를 
중단할 수는 없는 노릇이다.

이런 경우, 더 유연한 접근법을 사용할 수 있다.
`pdf` 함수는 신류 pdf 장치를 생성한다.
`pdf` 함수에 여러 인자를 사용해서, 크기와 해상도를 조절할 수 있다.


```{r, eval=FALSE}
pdf("Life_Exp_vs_time.pdf", width=12, height=4)
ggplot(data=gapminder, aes(x=year, y=lifeExp, colour=country)) +
  geom_line() +
  theme(legend.position = "none")

# You then have to make sure to turn off the pdf device!

dev.off()
```

저장한 문서를 열어서 살펴본다.

> ## 도전과제 1
>
> `pdf` 명령어를 다시 작성해서 pdf 파일에 두번째 페이지를 찍는다.
> 각 창 패널에 대륙별로 데이터를 패싯 도표(힌트: `facet_grid` 사용)로 출력한다.
> 
> > ## 도전과제 1에 대한 해답
> >
> > ```{r, eval = FALSE}
> > pdf("Life_Exp_vs_time.pdf", width = 12, height = 4)
> > p <- ggplot(data = gapminder, aes(x = year, y = lifeExp, colour = country)) +
> >   geom_line() +
> >   theme(legend.position = "none")
> > p
> > p + facet_grid(. ~continent)
> > dev.off()
> > ```
> {: .solution}
{: .challenge}

`jpeg`, `png` 등등 명령어도 다양한 형식으로 문서를 저장하는데,
유사하게 사용하면 된다.


## 데이터를 파일에 저장하기

어느 시점이 되면, R에서 데이터를 내보내서 파일에 저장하기도 한다.

이런 목적으로 `write.table` 함수를 사용하는데,
앞서 살펴본 `read.table` 함수와 매우 유사하다.

데이터 정제 스크립트를 생성하자. 
`gapminder` 데이터에서 Australia 호주만 집중한다:


```{r}
aust_subset <- gapminder[gapminder$country == "Australia",]

write.table(aust_subset,
  file="cleaned-data/gapminder-aus.csv",
  sep=","
)
```

쉘로 다시 전환해서, 모든 것이 정상인지 데이터를 살펴본다:

```{r, engine='bash'}
head cleaned-data/gapminder-aus.csv
```

음... 엄밀하게 보면 원하는 바는 아니다.
이 모든 인용부호는 어디서 왔을까?
또한 행번호도 보이는데 무의미하다.

도움말 파일을 살펴보고, 파일에 저장하는 방식을 변경해 본다.


```{r, eval=FALSE}
?write.table
```
기본디폴트 설정으로 데이터를 파일에 저장할 때, 
R은 자동으로 인용부호로 문자벡터를 감싼다.
행과 칼럼 명칭도 파일에 저장한다.

다음과 같이 고쳐본다:


```{r}
write.table(
  gapminder[gapminder$country == "Australia",],
  file="cleaned-data/gapminder-aus.csv",
  sep=",", quote=FALSE, row.names=FALSE
)
```

쉘 기술을 사용해서 다시 데이터를 살펴본다:

```{r, engine='bash'}
head cleaned-data/gapminder-aus.csv
```

훨씬 좋아보인다!

> ## 도전과제 2
>
> 1990 년 이후 수집된 데이터를 `gapminder` 데이터에서
> 부분집합으로 구성하는 데이터-정제 스크립트를 작성하라.
>
> 상기 스크립트를 사용해서, 작업한 신규 부분집합 데이터를 
> `cleaned-data/` 디렉토리에 파일로 저장한다.
>
> > ## 도전과제 2에 대한 해답
> >
> > ```{r, eval = FALSE}
> > write.table(
> >   gapminder[gapminder$year > 1990, ],
> >   file = "cleaned-data/gapminder-after1990.csv",
> >   sep = ",", quote = FALSE, row.names = FALSE
> > )
> > ```
> {: .solution}
{: .challenge}

```{r, echo=FALSE}
# We remove after rendering the lesson, because we don't want this in the lesson
# repository
unlink("cleaned-data", recursive=TRUE)
```
